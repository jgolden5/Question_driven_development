What is a load in a computer system? the number of processes that are either currently being executed by the cpu or are waiting for execution
What is load average? a system's average load (number of processes either currently being executed by the cpu or waiting for execution) over the last 1, 5 and 15 minutes
When is a load number modified? a stopped process starts or a running process stops; the load number is incremented in the former case and decremented in the latter case, thus the load cannot be below 0, and 0 indicates no running processes
Does a load number get calculated for the entire computer or for some sub-unit inside the computer? the entire computer
What does it mean when a system has a load of 0? the system is completely idle, meaning no processes are either using or waiting to use the cpu (cpu is "bing chillin")
What does it mean if a system's load is 7? it might be overloaded, depending on how many cpu cores the system has--if it has 1 cpu core, it means the system is VERY overloaded because 7 processes are waiting for cpu time, in a 4-core system it means that the system is overloaded, but not significantly, and in an 8-core system it means the system is near full utilization and not overloaded. In other words, if load <= number of cpu cores, the system is running well, but if load > number of cpu cores, the system is overloaded
What is computational work? the process of transforming input into output
What makes load metrics useful for system analysis? that it tracks how the cpu is handling recent processes
What units does load average use? running/waiting processes over time (specifically over 1, 5, and 15 minute intervals of time)
Why are load averages measured in 1, 5, and 15 minute intervals? you can use logic to observe how a system has worked over time, and load is a metric that requires time to be very useful, hence the fact that systems admins measure load AVERAGE instead of just load, so having multiple distinct time intervals gives us more information to learn from
What is the difference between cpu usage and load average? that cpu usage tells you what percentage of each cpu core is being used RIGHT NOW, whereas load average tells you the average number of processes either being used by or waiting to be used by the cpu OVER TIME
Is it sometimes a good thing for a load average to be high or a bad thing for load average to be low? yes, if you have enough cpu cores to handle the number of processes, it's ok, it means there is lots to do but the computer can handle it and was made to handle it, and a low load average can be a bad sign if it's indicating the opposite, that a computer with massive amounts of computing power is not in use , and its power may therefore be getting wasted if this occurs often
Is it always true that the more cores a cpu has, the better? no, it is only a good thing for a cpu to have as many cores as the software and workload can use efficiently, but many programs only use 1 or 2 cores, so the rest sit idle; in other words, even the hardware has all the power in the world, the software is likely designed for a relatively tame number of cpu cores, so being overly ambitious with the number of cpu cores my computer has can be a waste
How can a system be idle? simply starting up without running anything
How do load averages get calculated based on cpu cores? well, actually, uptime doesn't do any calculations, it literally tells you the load of how many processes are being handled by the system on average over the last 1, 5 and 15 minutes; the only "calculation" that needs to be done is if that load average is <= number of cpu cores on system, then it's able to handle the load, else the system is being overloaded by processes at some given time period
How does the /proc/loadavg file work on a linux system? providing the exact same information as uptime and then 2 additional pieces of data, the process queue (running n tasks out of p total processes), and the last pid created
How do I increase or decrease the load average of a linux system? running more applications and/or consuming more resources, increasing the number of concurrent users, shceduling more tasks to run automatically using a scheduler like cron, running more cpu intensive tasks like mathematical calculations, encryption, or compression, and increasing the number of threads a process uses to work (that was in order to increase load average in a system), and in order to decrease load average, upgrade the system's cpu, increase ram size in order to reduce swapping, optimize processes by fine-tuning configuration by reducing memory usage or running tasks at lower priorities, using cron to run background tasks at specific times instead of all at once, using containerization as with docker or k8s, killing unnecessary processes, and limiting the number of concurrent users on the system at once
What is a stress test? a way to test how well a computer can handle maximum usage over a sustained period
How might the total amount of time a system has been running be relevant to load average? giving the user context as to how long the system has been up in general, and can compare the standard uptime time specs to this grand total amount of time
What command displays the load average and number of cpu cores at the same time? mac: 'echo "cpu cores = $(sysctl -n hw.ncpu)" && uptime | sed 's/.*(load averages: .*)/1/''; linux: 'echo "CPU Cores: $(nproc) | Load Average: $(cat /proc/loadavg)"'
What causes a server to execute a high number of threads? activities that occupy the worker threads and don't release them, like a "thread leak" instead of a memory leak
What are the most common causes of high load average issues? cpu-intensive applications, insufficient ram allocation leading to excessive swapping, heavy disk i/o operations, network bottlenecks, poorly optimized applications, and a large number of concurrent processes competing for cpu resources
