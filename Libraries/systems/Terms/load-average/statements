A load in a computer system is the number of processes that are either currently being executed by the cpu or are waiting for execution.
Load average is a system's average load (number of processes either currently being executed by the cpu or waiting for execution) over the last 1, 5 and 15 minutes.
A load number is modified when a stopped process starts or a running process stops; the load number is incremented in the former case and decremented in the latter case, thus the load cannot be below 0, and 0 indicates no running processes (cpu is "bing chillin").
A load number gets calculated for the entire computer.
When a system has a load of 0, it means that the system is completely idle, meaning no processes are either using or waiting to use the cpu.
If a system's load is 7, it means that it might be overloaded, depending on how many cpu cores the system has--if it has 1 cpu core, it means the system is VERY overloaded because 7 processes are waiting for cpu time, in a 4-core system it means that the system is overloaded, but not significantly, and in an 8-core system it means the system is near full utilization and not overloaded. In other words, if load <= number of cpu cores, the system is running well, but if load > number of cpu cores, the sytem is overloaded.
Computational work is the process of transforming input into output.
What makes load metrics useful for system analysis is that it tracks how well the cpu is handling recent processes.
The units that load average uses is runnable or waiting processes over time (specifically over 1, 5, and 15 minute intervals of time).
Load averages are measured in 1, 5, and 15 minute intervals because you can use logic to observe how a system has worked over time, and load is a metric that requires time to be very useful, hence the fact that systems admins measure load AVERAGE instead of just load, so having multiple distinct time intervals gives us more information to learn from.
The difference between cpu usage and load average is that cpu usage tells you what percentage of each cpu core is being used RIGHT NOW, whereas load average tells you the average number of processes either being used by or waiting to be used by the cpu OVER TIME.
Yes, it IS sometimes a good thing for a load average to be high or a bad thing for load average to be low, because if you have enough cpu cores to handle the number of processes, it's ok, it means there is lots to do but the computer can handle it and was made to handle it, and a low load average can be a bad sign if it's indicating the opposite, that a computer with massive amounts of computing power is not in use , and its power may therefore be getting wasted if this occurs often.
Is it always true that the more cores a cpu has, the better? no, it is only a good thing for a cpu to have as many cores as the software and workload can use efficiently, but many programs only use 1 or 2 cores, so the rest sit idle; in other words, even the hardware has all the power in the world, the software is likely designed for a relatively tame number of cpu cores, so being overly ambitious with the number of cpu cores my computer has can be a waste.
A system can be idle by simply starting up without running anything.
Load averages get calculated based on cpu cores by well, actually, uptime doesn't do any calculations, it literally tells you the load of how many processes are being handled by the system on average over the last 1, 5 and 15 minutes; the only "calculation" that needs to be done is if that load average is <= number of cpu cores on system, then it's able to handle the load, else the system is being overloaded by processes at some given time period.
The /proc/loadavg file works on a linux system by providing the exact same information as uptime and then 2 additional pieces of data, the process queue (running n tasks out of p total processes), and the last pid created.
I increase or decrease the load average of a linux system by running more applications and/or consuming more resources, increasing the number of concurrent users, shceduling more tasks to run automatically using a scheduler like cron, running more cpu intensive tasks like mathematical calculations, encryption, or compression, and increasing the number of threads a process uses to work (that was in order to increase load average in a system), and in order to decrease load average, upgrade the system's cpu, increase ram size in order to reduce swapping, optimize processes by fine-tuning configuration by reducing memory usage or running tasks at lower priorities, using cron to run background tasks at specific times instead of all at once, using containerization as with docker or k8s, killing unnecessary processes, and limiting the number of concurrent users on the system at once.
A stress test is a way to test how well a computer can handle maximum usage over a sustained period.
The total amount of time a system has been running might be relevant to load average by giving the user context as to how long the system has been up in general, and can compare the standard uptime time specs to this grand total amount of time.
.
Something that causes a server to execute a high number of threads is activities that occupy the worker threads and don't release them, like a "thread leak" instead of a memory leak.
The most common causes of high load average issues are cpu-intensive applications, insufficient ram allocation leading to excessive swapping, heavy disk i/o operations, network bottlenecks, poorly optimized applications, and a large number of concurrent processes competing for cpu resources.
