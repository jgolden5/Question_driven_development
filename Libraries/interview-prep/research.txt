1 pdc
  a) constrain dataForms of dfb's passed in as values to this pdc's pdcb to only those that behave in the way that pdc is meant to (for example, WholeNumberDC would not accept a CharDF because it doesn't have a way to handle characters)

2 cdc 
  a) declares inners based on what's in DCHolder
  b) defines dcb relationships using requiredSetValues
  c) defines calculations of inner dcb's

3 ldc
  a) not needed right now, but kept for future use
  b) separates cdc's and allows one to be used as an input for the other while being otherwise independent (such as if nlDCB was plugged in externally with our more complex model of incorporating vcxDCB with cacxcyDCB)

4 dcb
  a) bind the abstract concept of dc and df to something concrete that can be written to or read from (dcb containing dfb)

5 calcInternal
  a) calls specific calc functions needed for retrieving any possible comibnation of missing data (eg. addition cdc needs to be able to calculate x + y = sum with x and sum, y and sum, or x and y)

6 dcHolder
  a) initiate all dc's and df's only once

7 df
  a) storing the same data in different forms, like 1, 1.0, "one", or "uno"

8 pdcb.put always clobbers
  a) simplification for user (they just have to call pdcb.put method and it will always set the value, and calling pdcb.get will always successfully retrieve the value if its outer is complete)
    i. pdcb.put
    ii. pdcb.get
  b) simplification for developer (if not for clobber-every-time mentality, pdcb.put would have to check all of its outers AND any OTHER outers of its neighbors to search for any possible duplicate, essentially repeating ALL the code used to calculate the internal method in the first place only to provide the boolean value of whether the values conflict)
    i. less repetition
    ii. simpler code
    iii. achieves same outcome--fetch occurs and calculation is done if the value isn't cached
    iv. the only case in which it would be worth it to check for conflicts before attempting calculation would be if the calculation took a large amount of time, but it doesn't 99% of the time

9 pdcb.calcNeighbor
  a) WARNING, this IS a mentally heavy concept to grasp
  b) if the pdcb calling calcNeighbor has an incomplete outer, it is impossible to calculate it from its outer, but may still be possible if one of the neighbors whose value pdcb depends on has a DIFFERENT outer that IS complete, because in that case said neighbor can be calculated, potentially making the original pdcb's outer now complete, and therefore making pdcb calculateable

10 pdcb.cacheVal
  a) stores a pdcb's value as a dfb after the value was found through calculation
