In java, @Nullable gives an explicit statement that the value might be null, so it instructs the programmer to use the variable in such a way that isn't as strict at checking for nullpointer exceptions, for example, and overall just keep in mind that that value has a purpose for being null sometimes.
If I remove inbound/outbound permitted from sockjsBridge, the required explicit permission for that event on the event bus to be listened to (inbound) or listened from (outbound) would not be given, and all events will fail to pass in those respective directions without said explicit permission.
What does the AbstractVerticle class do in Vertx? is an easy way to write one's own Verticle, through the extension of this class and overriding the start(Promise) method.
The purpose of rxjava3 in vertx is to be an external asynchronous library that cleanly aligns vertx with java (specifically in an observable way).
The purpose of SharedData in vertx is to allow you to share data safely between different parts of your application, using synchronous shared maps, as well as asynchronous maps, locks, and counters.
Vertx rxjava's Router acts as a central hub for incoming http requests, receiving them from an HttpServer, and then directing each request to the first matching route it finds within its configuration.
Sockjs is a javascript library that attempts to accomplish what websockets accomplishes, but it may provide only half-duplex, near-duplex, or full-duplex depending on the transport used; for exaample, if sockjs uses websockets, it will be full duplex, whereas if it uses something else like xhr-streaming it will be limited but near full-duplex, and if it uses something like jsonp-polling or eventSource, it will only be half-duplex.
Java BufferedReader enhances the efficiency of reading character input streams, including files and network sockets, by reading large chunks of data into an internal buffer (aka. instead of reading one character at a time, it uses a BUFFER).
Java InputStream serves as an abstract superclass for all classes that represent an input stream of bytes, providing a fundamental, consistent way to read data from a source, such as a file, network connection, or memory buffer, byte by byte; since it's an abstract class, it gets implemented by classe that use it, such as FileInputStream, BufferedInputStream, or ByteArrayInputStream.
Java Collectors class is used for performing mutable reduction operations on streams, which involves accumulating elements from a stream into a result container, often transforming them in the process.
The code that makes MainVerticle get treated as main class is the Main-Class and Main-Verticle fields in the file ./build/tmp/shadowJar/MANIFEST.MF, where . represents the root directory of the project.
For vertx to deploy a verticle means that it initiates and starts a running piece of vertx code called a verticle within the vertx runtime environment, allowing it to interact with other verticles asynchronously through the event bus and effectively execute as part of your application.
Vertx variable inside of AbstractVerticle is a reference to the vertx instance that deployed the verticle implementing AbstractVerticle.
Is SockJSBridge native to vertx? yes, it is a builtin feature of vertx that allows you to bridge communication between the vertx event bus and web clients using the sockjs javascript library, enabling real-time messaging capabilities with your application.
Is SockJSBridge native to vertx? yes, it's a core component that comes with vertx and doesn't require an external library to be added separately.
A SockJSHandler is a component within a web application framework (like vertx) that allows you to manage and handle connections from clients using the sockjs protocol.
The try and catch blocks in java are used for handling exceptions; try executes code, watching for any exceptions, and if an exception occurs, it executes code associated with said exception,, and the code can also have an optional finally block which gets executed after the try and catch blocks regardless of whether an exception occurred or not.
A Thread class in java is a representation of a virtual sense of a position on which code is getting executed in multithreaded programming, which enables concurrent (asynchronous) execution of code on different "threads".
A lock in asynchronous programming is a mechanism used to ensure that only one thread can access a shared resource at a time, preventing race conditions, even when multiple asynchronous operations are running concurrently.
A counter in asynchronous programming is a variable that keeps track of the number of asynchronous operations that have been completed, and is often used to determine when all operations in a set have finished before proceeding to the next step in the program.
The point of a jsonObject is to be a representation of a json object in java for formatting compatibility.
A consumer in an event bus is an application, service, or component that actively listens for and receives events published on an event bus, essentially acting as a subscriber that processes the received data and performs actions based on it; in other words, it is the entity that "consumes" the events published by producers on the bus.
The rxjava Message class is used for composing asynchronous, event-based programs by using observable sequences.
I always get multiple thread blocked errors when running my vertx app because whenever I use the debugger, it has to block my thread in order to step through code, because everything has been frozen in order to facilitate stepping through code, therefore, a vertx blocked thread error may only be ignored when I am debugging with breakpoints.
BrickVisurVars are used for basically just encapsulating the internal calculations of dataClassBricks and reducing the complexity to simple get/put functions in visur.
Hashmaps work by following a general hash concept where a unique hash exists for every element in the hash map, and a key maps to the value at said hash, such that read and write operations are done with O(1) time complexity; hashmaps have an initial capacity and a load factor, and if the initial capacity times load factor exceeds the current number of elements in the hash map, the capacity roughly doubles.
The purpose of implementing EditorContentService and EditorModelCoupler separately was to separate concerns regarding service classes, and bind them all together with the EditorModelCoupler so that the user would not need to worry about which services were going where, and that the services could each respectively pull in only the variables relative to them and there would not need to be a global structure to do this as there was back when EditorModelCoupler was EditorModelService.
The purpose of LocalMap in vertx is to allow for a thread-safe, in-memory, map that allows you to share data between different parts of a single vertx instance, essentially acting as a local data cache, used to stored data that needs to be accessible across multiple verticles running on the same vertx instance.
LocalMap relates with SharedData in vertx by the fact that SharedData is an interface which provides LocalMap.
Emc.getStrToMatch() is used for finding the quantum limits by inching one character at a time towards the editor content length limit without exceeding that limit (note this is only used for RegexQuantum in visur.
No, event buses in vertx do NOT always listen at the url address /eventbus because the event bus is an internal messaging system for the vertx components, and when used on a network the endpoint url is configurable.
InitializerInsertKeymap and InsertModeHandler are separated with insertNewline being a function only in InsertModeHandler because I must have gotten confused; this has now been fixed.
The time complexity of the InsertCharOp in visur is o(n) in the backend because of the nextLineIndices getting updated every time where n = the number of elements in nextLine array, and of course, o(n^2) on the front end because of the 2-dimensional canvas getting drawn.
InsertNewlineOp is a longer function than InsertCharOp even though the actual newline is specified explicitly so in theory InsertNewlineOp should be shorter because ca has to get incremented in InsertNewlineOp and I also redundantly updated newlineChars even though that gets done inside the putEditorContent method which I also called,.
A stream is a source of input abstracting away (hiding) another source--as long as the abstraction is not broken the code will be very flexible.
Observable means a data source that can emit multiple values over time, acting like a stream of data that can be subscribed to in order to receive updates whenever new values are produces; it iss essential to asynchronous programming.
