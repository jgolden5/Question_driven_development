CompoundDataClasses exist in order to provide solid consistent rules based on very specific relationships, particularly supplying a requiredSetValues field which is used to define dataClassBrick releationships.
The calcInternal method is used for basically acting as the a router to the specific calc functions pertaining to each dataClass in dataClass framework.
DCHolders are used for ensuring that all the dc's and df's only get instantiated once inside a specialized container (whatever class extends DCHolder, like CursorPositionDCHolder).
Pdcb.put() methods clobber any possible conflicts because as far as the user is concerned, it doesn't matter which variable is set as long as enough variables are set in order to calculate the other one, since we aren't dealing with any crazy intense calculations, therefore it's just simpler to clobber any possible conflicts instead of repeating logic to prove there are none.
The purpose of LayeredDataClass is a little bit of baggage that was needed for the more complicated use case where we wanted multiple compoundDataClass instances to be independent of each other but still connect to other dataClasses as external dependencies; even though we don't need it now, we kept the feature because it's already implemented and we will likely need it again in the future.
DataForms are for literally storing the same data in different forms, like 1 can be represented as 1, 1.0, 1.000, one, or uno, depending on the context.
Pdcb.calcNeighbor() is for calculating a value not available by calculating the inners of the current outer dcb by going to a different outer of a neighboring pdcb, but an outer that IS complete, so that the missing pdcb can be calculated and the current odcb will be complete as well so that the pdcb that called calcNeighbor can ALSO be calculated.
Pdcb.cacheVal() is for setting a dcb's dataFormBrick.
